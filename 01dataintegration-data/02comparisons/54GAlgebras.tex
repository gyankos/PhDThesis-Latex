\subsection{Graph Algebras}\label{cite:galg}
Within the field of database query languages, a (relational) algebra is a data structure (e.g., finitary relations in the case of Codd's \textit{relational algebra}) that is closed under certain operators. The aim of such languages is to provide a semantics and optimizations to declarative programming languages (e.g. SQL for the \textit{relational algebra} \cite{Ceri1985}) such that it can be used within the databases' query plans to obtain, through their rewriting rules (i.e. \textit{equational reasoning}), the most efficient query providing the equivalent result, independently from the data actually stored within the database. Moreover, algebras express graph transformation that are either impossible or hard to provide through graph rewriting, such as the basic graph set operators (union, intersection, difference over the vertices' and edges' set) and binary graph operators (join).

Currently there are two types of algebras that have been developed for graphs: path algebras and (proper) graph algebras. While path algebras have been developed to provide a formal semantics to path traversal and graph pattern matching queries, graph algebras have been designed either to change the structure of property graphs through unary operators, or to combine then through binary ones (e.g., the graph join and graph nesting that will be respectively introduced in Chapter \vref{cha:join} and \vref{cha:nesting}). Among all the path algebras, only path algebras have been studied for both expressing equivalence rules (for SPARQL, \cite{Perez2009}) for providing path evaluations' optimizations (for Cypher, \cite{Neo4jAlg}) and allowing incremental updates (for SPARQL, \cite{SparqlIncr}). On the other hand, due to the fact that such algebras were only designed for path manipulation and not for returning graphs, they cannot be directly used to return graphs.

Property graphs (and their extensions) also fail both to be closed under their proposed (proper) graph algebras, and to provide some interesting rewriting rules. The reason for this is twofold: firstly, the need to express graph collections and graphs for some graph data analysis tasks \cite{apacheflink} and the impossibility of expressing them both within the same representation under the property graph model requires the algebras to design four distinct class of operators: graph to graph operators, graph to graph collection operators \cite{JunghannsKAPR17}, graph collection to graph collection operators \cite{He2007}, and graph collections to graph operators \cite{apacheflink}. Therefore, no simple rewriting rules can be modelled on top of such algebras (GRAD \cite{GRAD,Ghrab2015} and GrALa \cite{apacheflink}): such problem was originated by  their ancestor GraphQL\footnote{Not to be confused with Facebook's GraphQL query language \cite{FGraphQL}.} \cite{He2007}. Moreover, those algebras were designed more to be useful APIs to the programmers than actual tools for query optimization: this intuition is supported by their implementation, focusing more on the algorithmic enchancement of the single operator and not on how such operators interact \cite{JunghannsPR17}. Moreover, the graph collection to graph collection operators do not implement all the possible collection operators as outlined in \cite{magnani04}: as an example, proper join operations are missing.

Last, some of the path algebras do not distinguish data from the operator themselves, and hence data became actually $\zero$-ary operators \cite{Neo4jAlg,MartonSV17,ThakkarPAV17}, that have no sense with respect to standard algebras, where the data itself is not expressed as an operator.

\phparagraph{GraphQL, GrALa and GRAD}
\textbf{GraphQL} \cite{He2007} is yet another graph query language with an SPARQL-like syntax, mainly conceived
for pattern extraction from the data, called \textit{graph motifs}, and their construction. The language
allows graphs naming similarly to SPARQL \textit{named graphs}. The most interesting scientific contribution
of He \cite{He2007} is the first attempt in defining a graph algebra for collection of graphs.

This approach has been finally specialized for single graphs in the \textbf{GRAD} algebra \cite{GRAD,Ghrab2015}. In this
latter definition the \textit{cartesian product} and \textit{join} operations are still defined over
graph collections and are still not specialized for the single graphs. Consequently, in both languages
the cartesian product over two graph collections produces a graph containing two (possibly) disjoint graph
components. The graph join over the two collections only merges the matched vertices and no considerations
are made on the graphs' edges structure. In the end, GRAD propose an alternative
graph data model that could be expressed as a specific implementation of the Property Graph model.

On the other hand, graph joins are completely missing on the other development of the GraphQL algebra, that is \textbf{GrALa} \cite{apacheflink}: its graph pattern matching through \textit{graph motifs} inspired the recent pattern matching operator \cite{JunghannsKAPR17}, acting both as a graph traversal and as a proper pattern matching query interpretation on top of Cypher's query syntax. Last, the dichotomy between graph and graph collection inspired the authors to extend the basic property graph model to support graph collections within a same graph database (see Section \ref{php:EPGM} for further reference on their data model). The definition of graph operators for such algebra is still under development.
