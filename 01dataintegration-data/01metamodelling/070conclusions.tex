\section{Conclusions}

After describing how is it possible to carry out data integration for some data representations, we discussed how to set up
%This chapter focused on  
a general framework for data integration abstracting from a specific data representation. %, it provides the schema that has to be later on implemented with a specific data structure and, the provided operations, has to be implemented using a specific graph query language. 
 Moreover, it has been said that some languages (such as SQL and SROIQ) fail at representing either data integration or alignment tasks. %if it exists a query language allowing to provide all the aforementioned operations on a specific data representation. Chapters \ref{cha:datadef} and \vref{cha:graphsdef} will compare different data models and focus on the specification of an appropriate nested graph representation, while Chapter \vref{sec:dbqlang} will start to address the problem concerning existing (graph) query languages. 
This framework hence requires both an intermediate data model, towards which all the possible incoming data representations may be mapped to, and a query language (over such general representation) allowing to express some  queries currently used for querying distinct types of data sources. As we're going to see in Chapter \ref{cha:NGQL}, such query language is also able to express the $\Qoppa$, $\alpha$ and $\nu_\cong$ operators for data integration, that can now be only supported outside traditional query languages. All these concepts are going to be addressed and solved within this thesis, either from a formal point of view, or on an algorithmic one ($\nu$ and $\bowtie$). We're going to draw our final conclusions at Chapter \ref{cha:IteMissaEst}. 