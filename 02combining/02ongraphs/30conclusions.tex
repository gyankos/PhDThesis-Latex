\section{Conclusions}
%This chapter showed that the proposed nested graph model allows to overcome several limitations related to data aggregations, both using data aggregations through nesting operations and hierarchical driven ones. 
%It was also showed that data integration operations can be also carried out by using the same operations provided in the Related Work Part for relational databases. As a consequence, some graph operations implementing such tasks and generalizing the latter ones are required. In particular, the next Chapter will focus on which are the relevant operations for graph data, while the following one will focus on the nesting operator.

This chapter allowed to introduce the topic of data integration: as required by the \textsc{Global as a View} scenario, a general data representation for integrating different data sources is provided. This intermediate representation is the Generalized Semistrucured Model, GSM for short, which allowed the definition of the $\tau$ translation operators required by Definition \vref{def:GAV}. If we have some more precise information concerning the original data, we can then elect which  objects have to be considered as entities and which others are promoted to relationships: after this intermediate step, we can now transform a GSM into a Nested Graph by providing the schema to which the final data must comply to. 

Another similar approach for data matching and rewriting is going to be provided in the next chapter as a generalization of the graph grammars.

%consequently, the nested graph model made explicit such relations by enriching the GSM model with specific expressions. Then, 

The last section also showed how GSM promotes a better alignment between entities and attributes (both represented as objects). %, and hence showed how the hub schema matching and data transformation operation can be carried out, thus allowing to outline the $\Qoppa$ operator, resembling a graph rewriting process that will be discussed in depth in the following chapter. 
In particular, the data objects are associated to the hub schema $H$ via the (intermediate data) schemas $\alpha(D)$: after matching the data to its schema and refining the correspondences, we obtain a grammar rule $\alpha(D)\to H$. Then, by filtering out the data in $D$, we create direct correspondences between $D$ and $H$.
After a data cleaning phase which on which we will not linger because it is a topic already addressed in literature ($\nu_\cong$), we'll have to discuss which is the actual language on which we can express our query $q$ over the nested graph model. %As we will see in the next chapter, $\Qoppa$ will be one of the operators for our algebra, GSQL, over which any other query $q$ can be expressed. Consequently, 
The chapter that follows will conclude our theoretical framework by defining such query language, while the second last chapter will focus more on algorithmic and implementation issues concerning an algorithm for a specific instance of the nesting operator, $\nu$.