%\subsection{(*) Graph Nesting: Generalizing the semistructured nesting operator}
The nesting operator for nested relations \cite{liu05,paredaens1992} allows nesting other attributes belonging to a same relation inside a field belonging to the same relation. If we look at the definition of a nested graph, vertices and edges are not explicitly defined as values associated to an attribute of a specific object inside database. Consequently, the traditional nesting operation for nested relations cannot help us for the definition of an operator allowing to store a subgraph of a given nested graph inside either a vertex, or another edge. We must also note that we cannot create new vertices matched by different graphs $H_i$ and link them by newly created edges by using a link discovery predicate over such predicates, we must necessarily apply a second operator (either a link discovery or a generalized graph grammar operator) for the creation of such edges.

%Let us discuss now the creation of the new vertices first. As we have already seen in the previous subsection, generalized graph grammars allow to trasform each matched subgraph specified as a head $H_i$, into a single vertex represented in a trasformation graph $T_i$, eventually containing all the matched vertices and edges. Consequently, we can define such grammar as follows:
%\[\mathcal{VG}=[(V_i,E_i,A_i,\Lambda_i,\ell_i,\lambda_i,\iota_i)\to (\Set{v_i},\emptyset,A_i\cup\{g\},\Lambda_i,\ell_i,\lambda_i,\iota_i\oplus [v_i\mapsto \psi_V^j([i])])]_{i\leq n}^{s_i}\]
%where each vertex $v_i$ contained in the translation graph $T_i$ is not contained by the vertex set of $H_i$ and contains all the matched elements in $H_i$ ($\;v_i(g):=(\cdot,\iota(V_{H_i})\cup\iota(E_{H_i}))\;$). 

%As a next step, we shall define a new grammar $\mathcal{EG}$ linking all the vertices created by $\mathcal{VG}$ or remaining from the original graph. As a consequence, each head in $\mathcal{EG}$ must contain vertices and edges that must necessairly be represented in the respective graph tail, where new edges are added ($H_i\subseteq T_i$, such that $V_{H_i}=V_{T_i}$ and $E_{H_i}\subset E_{T_i}$). If two subsequent generalized graph grammar rules satisfy the aforementioned properties, then they provide the definition of a graph nesting operator:
%\[\nu_{\mathcal{VG},\mathcal{EG}}(N)=\mathcal{EG}(\mathcal{VG}(N))\]

Therefore, even this operator cannot be used in practice to define a general operator allowing graph nesting. The next chapter is going to provide another possible solution for graph nesting by incorporating the definition of the semistructured grouping operators and by allowing vertices' and edges' grouping contemporarily.

Before closing this chapter, we should ask ourselves whether this operator actually matches within the requirements of $\Qoppa$, that already appeared in Section \vref{subsec:queryrw} and \vref{sec:ngusecases}, where we also provided an algorithm for transforming the morphisms associated to the source schema into morphisms associated to the hub schema. As we can see, this approach is more general than the previous one, because through $\mathcal{G}$ we can even create new elements as aggregations of the matched elements which have not been returned by the graph transformation phase. Notwithstanding, this graph grammar operator $\mathcal{G}$ is more general than the other one required in the data integration scenario, because even the non matched objects within the head pattern are returned, while in the previous approach we only return the matched objects, and we distinguish different possible matchings between the head and tail pattern. First, if we want to remove the unmatched elements from the final vertex and edge set, we can simply restate the former definition as follows$\index{\Qoppa!from generalized graph grammars}$:
\[\qtransl_{\mathcal{H},\mathcal{T}}^{\mathcal{G}}(\mathcal{H})(\nested)=\texttt{elect}_{o_{c+1}}(\texttt{create}_{[],[],[[\ONTA,\delta V],[\RELA,nE]]}^{\textup{\textbf{let } } o_c = \max O \textup{ \textbf{ in } } o_{c+1}}(\nested_E(\nested_V(\nested))))\]
Moreover, if we have simple GSMs not represented as nested graphs, we can simply ignore the returned edges. Now, the two techniques only differ from qualitative measures, but they have no specific distinctions from a formal point of view (that is, they both adhere to the specifics, but they substantially differ in the structure of the returned result). Therefore, further tests have to be carried out in order to test the quality of both $\Qoppa$ definitions, in order to check which of the two provide the best expected results from a user experience point of view. We address to some future work on establishing which of the two definitions is better for data integration within nested data.


\section{Conclusons}
This chapter provided the definition of the GSQL query language expressed through an algebra, which was able to express set, relational, semistructured and (nested) graph operators. In particular, it was showed that such operators were able to implement all the missing operators required for the GAV data integration scenario, which are the schema extraction (via aggregation) and the matching with rewriting ($\Qoppa$) by generalizing the properties of graph rewriting and pattern matching. On the other hand, we do not still provide a full definition of all the possible graph data operators but  we showed that it is possible to combine the semistructured operations with the edge creation ones to create new nested graphs. 

Last, we also showed how such algebra allows to represent the previously defined graph joins. In the next chapter, we're going to introduce another graph operator, which is the graph nesting, thus allowing to nest vertex and edge informations in both vertices and edges. As we will se in the incoming chapter, the features of this GSQL algebra will be useful to provide optimization when a high level algebraic operator needs to be combined with a pattern matching graph visit, when both can be expressed within the same language. As we will see, this possibility is going to lead to better optimizations and, therefore, we're going to create an algorithm, where both graph visit and new graph creations are combined together.

We also remark some futher works that should be carried out on GSQL:
\begin{itemize}
\item Provide some equivalence rules for GSQL if any.
\item If there are some equivalence rules, provide some query rewriting optimizations as it currently happens on relational models' query plans. 
\item Similarly to the relational $\bowtie_\theta$, check if there are other set of operators that can grouped and provide better optimizations within one single definition that in multiple disaggregated operators.
\item Provide a more formal definition for a nested graph traversal language, combining XPath's and NautiLOD's semantics.
\item As it will be outlined in the next chapter, check if there are some cases when traversals may be provided as a predicate for a GSQL operator and, given that both graph traversal and GSQL are represented in GSQL itself, check if the former types of optimization provide some benefit.
\end{itemize} 